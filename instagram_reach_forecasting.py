# -*- coding: utf-8 -*-
"""Instagram Reach Forecasting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xVbWY2R38_ZW4T20EM1BothM3IzS9YPR

Importing Necessary Libraries and Dataset
"""

import pandas as pd
import numpy as np
import plotly.graph_objs as go
import plotly.express as px
import plotly.io as pio
from plotly.tools import mpl_to_plotly
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_pacf
import statsmodels.api as sm
import warnings
pio.templates.default = "plotly_white"

data = pd.read_csv("Instagram-Reach.csv", encoding = 'latin-1')
print(data.head())

# Convert the Date column into datetime datatype
data['Date'] = pd.to_datetime(data['Date'])
print(data.head())

"""Analyzing Reach"""

# Analyze the trend of Instagram reach over time using a line chart
fig = go.Figure()
fig.add_trace(go.Scatter(x=data['Date'],
                         y=data['Instagram reach'],
                         mode='lines', name='Instagram reach'))
fig.update_layout(title='Instagram Reach Trend', xaxis_title='Date',
                  yaxis_title='Instagram Reach')
fig.show()

# Analyze Instagram reach for each day using a bar chart
fig = go.Figure()
fig.add_trace(go.Bar(x=data['Date'],
                     y=data['Instagram reach'],
                     name='Instagram reach'))
fig.update_layout(title='Instagram Reach by Day',
                  xaxis_title='Date',
                  yaxis_title='Instagram Reach')
fig.show()

# Analyze the distribution of Instagram reach using a box plot
fig = go.Figure()
fig.add_trace(go.Box(y=data['Instagram reach'],
                     name='Instagram reach'))
fig.update_layout(title='Instagram Reach Box Plot',
                  yaxis_title='Instagram Reach')
fig.show()

# Create a day column and analyze reach based on the days of the week
data['Day'] = data['Date'].dt.day_name()
print(data.head())

# Analyze the reach based on the days of the week
# Group the DataFrame by the Day column and calculate the mean, median, and standard deviation of the Instagram reach column for each day
day_stats = data.groupby('Day')['Instagram reach'].agg(['mean', 'median', 'std']).reset_index()
print(day_stats)

# Create a bar chart to visualize the reach for each day of the week
fig = go.Figure()
fig.add_trace(go.Bar(x=day_stats['Day'],
                     y=day_stats['mean'],
                     name='Mean'))
fig.add_trace(go.Bar(x=day_stats['Day'],
                     y=day_stats['median'],
                     name='Median'))
fig.add_trace(go.Bar(x=day_stats['Day'],
                     y=day_stats['std'],
                     name='Standard Deviation'))
fig.update_layout(title='Instagram Reach by Day of the Week',
                  xaxis_title='Day',
                  yaxis_title='Instagram Reach')
fig.show()

"""Forecasting"""

# Use Time Series Forecasting
data = data[["Date", "Instagram reach"]]

result = seasonal_decompose(data['Instagram reach'],
                            model='multiplicative',
                            period=100)

fig = plt.figure()
fig = result.plot()

fig = mpl_to_plotly(fig)
fig.show()

"""The reach is affected by seasonality, so we can use the SARIMA model to forecast the reach of the Instagram account. We need to find p, d, and q values to forecast the reach of Instagram. To find the value of d, we can use the autocorrelation plot, and to find the value of q, we can use a partial autocorrelation plot. The value of d will be 1."""

# Visualize an autocorrelation plot to find the value of p
pd.plotting.autocorrelation_plot(data["Instagram reach"])

# Visualize a partial autocorrelation plot to find the value of q
plot_pacf(data["Instagram reach"], lags = 100)

# Train a model using SARIMA
p, d, q = 8, 1, 2

model=sm.tsa.statespace.SARIMAX(data['Instagram reach'],
                                order=(p, d, q),
                                seasonal_order=(p, d, q, 12))
model=model.fit()
print(model.summary())

"""Make predictions using the model and take a look at the forecasted reach"""

predictions = model.predict(len(data), len(data)+100)

trace_train = go.Scatter(x=data.index,
                         y=data["Instagram reach"],
                         mode="lines",
                         name="Training Data")
trace_pred = go.Scatter(x=predictions.index,
                        y=predictions,
                        mode="lines",
                        name="Predictions")

layout = go.Layout(title="Instagram Reach Time Series and Predictions",
                   xaxis_title="Date",
                   yaxis_title="Instagram Reach")

fig = go.Figure(data=[trace_train, trace_pred], layout=layout)
fig.show()

